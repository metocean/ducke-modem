// Generated by CoffeeScript 1.8.0
var HttpDuplex, stream,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

stream = require('readable-stream');

module.exports = HttpDuplex = (function(_super) {
  __extends(HttpDuplex, _super);

  function HttpDuplex(req, res, options) {
    this.end = __bind(this.end, this);
    this._write = __bind(this._write, this);
    this._read = __bind(this._read, this);
    this.connect = __bind(this.connect, this);
    var self;
    self = this;
    HttpDuplex.__super__.constructor.call(this, options);
    this._output = null;
    this.connect(req, res);
  }

  HttpDuplex.prototype.connect = function(req, res) {
    var self;
    self = this;
    this.req = req;
    this._output = res;
    this.emit('response', res);
    res.on('data', (function(_this) {
      return function(c) {
        if (!_this.push(c)) {
          return _this._output.pause();
        }
      };
    })(this));
    return res.on('end', (function(_this) {
      return function() {
        return _this.push(null);
      };
    })(this));
  };

  HttpDuplex.prototype._read = function(n) {
    if (this._output) {
      return this._output.resume();
    }
  };

  HttpDuplex.prototype._write = function(chunk, encoding, cb) {
    this.req.write(chunk, encoding);
    return cb();
  };

  HttpDuplex.prototype.end = function(chunk, encoding, cb) {
    return this.req.end(chunk, encoding, cb);
  };

  return HttpDuplex;

})(stream.Duplex);
